name: Ansible Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        default: 'dev'
        options:
          - dev
          - staging
          - prod
      instance_id:
        description: 'EC2 Instance ID (optional if providing custom inventory)'
        required: false
        type: string
        default: 'i-0d80cf0c8f79135c0'
      cloudfront_url:
        description: 'CloudFront URL (optional)'
        required: false
        type: string
      image_url:
        description: 'Image URL (optional)'
        required: false
        type: string
      secrets_manager_arn:
        description: 'Secrets Manager ARN for CloudFront header (optional)'
        required: false
        type: string
      elastic_ip:
        description: 'EC2 Elastic IP for direct access test (optional)'
        required: false
        type: string
      ansible_inventory:
        description: 'Raw Ansible inventory content (optional, overrides generated)'
        required: false
        type: string

permissions:
  id-token: write
  contents: read
  actions: read

env:
  AWS_REGION: 'us-east-1'

jobs:
  deploy:
    name: Deploy Image via Ansible
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Ansible-${{ github.run_id }}


      - name: Load inputs
        id: config
        run: |
          echo "Loading inputs..."
          INSTANCE_ID="${{ inputs.instance_id }}"
          CLOUDFRONT_URL="${{ inputs.cloudfront_url }}"
          IMAGE_URL="${{ inputs.image_url }}"
          SECRETS_MANAGER_ARN="${{ inputs.secrets_manager_arn }}"
          ELASTIC_IP="${{ inputs.elastic_ip }}"

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "cloudfront_url=$CLOUDFRONT_URL" >> $GITHUB_OUTPUT
          echo "image_url=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "secrets_manager_arn=$SECRETS_MANAGER_ARN" >> $GITHUB_OUTPUT
          echo "elastic_ip=$ELASTIC_IP" >> $GITHUB_OUTPUT

          echo "Inputs loaded"

      - name: Prepare CloudFront secret
        id: secrets
        run: |
          ARN="${{ steps.config.outputs.secrets_manager_arn }}"
          if [ -n "$ARN" ]; then
            echo "Fetching CloudFront secret header from AWS Secrets Manager..."
            SECRET_JSON=$(aws secretsmanager get-secret-value \
              --secret-id "$ARN" \
              --query SecretString \
              --output text)
            HEADER_NAME=$(echo "$SECRET_JSON" | jq -r '.header_name')
            HEADER_VALUE=$(echo "$SECRET_JSON" | jq -r '.header_value')
            echo "::add-mask::$HEADER_VALUE"
            echo "header_name=$HEADER_NAME" >> $GITHUB_OUTPUT
            echo "header_value=$HEADER_VALUE" >> $GITHUB_OUTPUT
            echo "Secret fetched successfully"
          else
            echo "CloudFront disabled or no secret ARN provided; skipping secret fetch."
            echo "header_name=" >> $GITHUB_OUTPUT
            echo "header_value=" >> $GITHUB_OUTPUT
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Ansible and dependencies
        run: |
          pip install --upgrade pip
          pip install ansible boto3 botocore
          ansible-galaxy collection install amazon.aws community.general

      - name: Install AWS Session Manager Plugin
        run: |
          curl "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"
          sudo dpkg -i session-manager-plugin.deb
          session-manager-plugin --version

      - name: Wait for instance to be ready
        if: ${{ inputs.instance_id != '' }}
        run: |
          echo "Waiting for SSM agent to be online..."
          INSTANCE_ID="${{ steps.config.outputs.instance_id }}"
          
          for i in {1..30}; do
            STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text 2>/dev/null || echo "NotFound")
            
            if [ "$STATUS" = "Online" ]; then
              echo "âœ… Instance is online and ready!"
              break
            fi
            
            echo "Attempt $i/30: Instance status is $STATUS, waiting 10s..."
            
            if [ $i -eq 30 ]; then
              echo "::error::Instance did not come online within timeout"
              exit 1
            fi
            
            sleep 10
          done

      - name: Verify AWS SSM connectivity
        run: |
          echo "Testing direct SSM connection..."
          aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=${{ steps.config.outputs.instance_id }}" \
            --query "InstanceInformationList[0]" || echo "SSM info retrieval failed"
          
          echo "Testing SSM command execution..."
          aws ssm send-command \
            --instance-ids "${{ steps.config.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["echo test"]' \
            --query "Command.CommandId" \
            --output text || echo "SSM send-command failed"

      - name: Create Ansible config and inventory
        run: |
          # Create ansible.cfg with SSM settings
          cat > ansible.cfg << 'EOFCFG'
          [defaults]
          host_key_checking = False
          inventory = inventory.ini
          timeout = 60
          
          [ssh_connection]
          
          [inventory]
          enable_plugins = aws_ec2, host_list, auto, yaml, ini
          EOFCFG
          
          # Create inventory with SSM connection params
          if [ -n "${{ inputs.ansible_inventory }}" ]; then
            echo "Using provided inventory content"
            printf "%s\n" "${{ inputs.ansible_inventory }}" > inventory.ini
          elif [ -n "${{ steps.config.outputs.instance_id }}" ]; then
            echo "Generating SSM inventory using instance_id"
            cat > inventory.ini << 'EOFINV'
[ec2_servers]
ec2-instance

[ec2_servers:vars]
ansible_host=${{ steps.config.outputs.instance_id }}
ansible_connection=aws_ssm
ansible_aws_ssm_bucket_name=
ansible_aws_ssm_region=${{ env.AWS_REGION }}
EOFINV
          else
            echo "::error::Provide either 'instance_id' or 'ansible_inventory' input"
            exit 1
          fi
          
          echo "Ansible config created:"
          cat ansible.cfg
          echo ""
          echo "Inventory created:"
          cat inventory.ini

      - name: Test direct SSM command
        run: |
          echo "Testing direct SSM shell command..."
          aws ssm start-session --target ${{ steps.config.outputs.instance_id }} \
            --document-name AWS-StartNonInteractiveCommand \
            --parameters 'command=["echo SSM works"]' || echo "Direct SSM failed"

      - name: Skip Python bootstrap (already in AL2023)
        run: |
          echo "Amazon Linux 2023 includes Python3 by default; skipping bootstrap."

      - name: Run Ansible playbook
        env:
          CLOUDFRONT_SECRET_HEADER: ${{ steps.secrets.outputs.header_name }}
          CLOUDFRONT_SECRET_VALUE: ${{ steps.secrets.outputs.header_value }}
          ANSIBLE_HOST_KEY_CHECKING: 'False'
          ANSIBLE_STDOUT_CALLBACK: 'yaml'
        run: |
          echo "Deploying image with Ansible..."
          ansible-playbook \
            -i inventory.ini \
            deploy-image.yml \
            -v \
            --timeout 300

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          CLOUDFRONT_URL="${{ steps.config.outputs.cloudfront_url }}"
          IMAGE_URL="${{ steps.config.outputs.image_url }}"
          
          if [ -n "$CLOUDFRONT_URL" ]; then
            echo "Testing CloudFront URL..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$CLOUDFRONT_URL" || echo 000)
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… CloudFront is responding correctly"
            else
              echo "âš ï¸  CloudFront returned HTTP $HTTP_CODE (may need time to propagate)"
            fi
          else
            echo "CloudFront URL not provided; skipping CloudFront test."
          fi

          if [ -n "$IMAGE_URL" ]; then
            echo "Testing image URL..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$IMAGE_URL" || echo 000)
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Image is accessible"
            else
              echo "âš ï¸  Image returned HTTP $HTTP_CODE (may need time to propagate)"
            fi
          else
            echo "Image URL not provided; skipping image test."
          fi

      - name: Test direct EC2 access (should be blocked)
        if: ${{ inputs.elastic_ip != '' }}
        continue-on-error: true
        run: |
          echo "Testing that direct EC2 access is blocked..."
          ELASTIC_IP="${{ steps.config.outputs.elastic_ip }}"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$ELASTIC_IP/logo.png" || echo "000")
          if [ "$HTTP_CODE" = "403" ]; then
            echo "âœ… Direct EC2 access is properly blocked (403 Forbidden)"
          elif [ "$HTTP_CODE" = "000" ]; then
            echo "âœ… Direct EC2 access is blocked (connection refused/timeout)"
          else
            echo "âš ï¸  Direct EC2 returned HTTP $HTTP_CODE (expected 403)"
          fi

      - name: Display deployment summary
        if: success()
        run: |
          echo "============================================"
          echo "ðŸŽ‰ Deployment Completed Successfully!"
          echo "============================================"
          echo ""
          echo "ðŸ“¸ Image URL:"
          echo "   ${{ steps.config.outputs.image_url }}"
          echo ""
          echo "ðŸŒ CloudFront Distribution:"
          echo "   ${{ steps.config.outputs.cloudfront_url }}"
          echo ""
          echo "ðŸ”’ Security Status:"
          echo "   âœ… CloudFront HTTPS enforced"
          echo "   âœ… Origin verification enabled"
          echo "   âœ… Direct EC2 access blocked"
          echo "   âœ… Security headers applied"
          echo ""
          echo "ðŸ§ª Test your deployment:"
          echo "   curl -I ${{ steps.config.outputs.image_url }}"
          echo ""
          echo "ðŸ“¦ Instance ID: ${{ steps.config.outputs.instance_id }}"
          echo "ðŸ”§ Connect via SSM:"
          echo "   aws ssm start-session --target ${{ steps.config.outputs.instance_id }}"
          echo "============================================"

      - name: Upload deployment logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ansible-logs-${{ inputs.environment }}-${{ github.run_number }}
          path: |
            *.log
            deployment-config/
          retention-days: 7
          if-no-files-found: ignore
