name: Ansible Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        default: 'dev'
        options:
          - dev
          - staging
          - prod
      instance_id:
        description: 'EC2 Instance ID (optional if providing custom inventory)'
        required: false
        type: string
        default: 'i-0d80cf0c8f79135c0'
      cloudfront_url:
        description: 'CloudFront URL (optional)'
        required: false
        type: string
      image_url:
        description: 'Image URL (optional)'
        required: false
        type: string
      secrets_manager_arn:
        description: 'Secrets Manager ARN for CloudFront header (optional)'
        required: false
        type: string
      elastic_ip:
        description: 'EC2 Elastic IP for direct access test (optional)'
        required: false
        type: string
      ansible_inventory:
        description: 'Raw Ansible inventory content (optional, overrides generated)'
        required: false
        type: string

permissions:
  id-token: write
  contents: read
  actions: read

env:
  AWS_REGION: 'us-east-1'

jobs:
  deploy:
    name: Deploy Image via Ansible
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Ansible-${{ github.run_id }}


      - name: Load inputs
        id: config
        run: |
          echo "Loading inputs..."
          INSTANCE_ID="${{ inputs.instance_id }}"
          CLOUDFRONT_URL="${{ inputs.cloudfront_url }}"
          IMAGE_URL="${{ inputs.image_url }}"
          SECRETS_MANAGER_ARN="${{ inputs.secrets_manager_arn }}"
          ELASTIC_IP="${{ inputs.elastic_ip }}"

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "cloudfront_url=$CLOUDFRONT_URL" >> $GITHUB_OUTPUT
          echo "image_url=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "secrets_manager_arn=$SECRETS_MANAGER_ARN" >> $GITHUB_OUTPUT
          echo "elastic_ip=$ELASTIC_IP" >> $GITHUB_OUTPUT

          echo "Inputs loaded"

      - name: Prepare CloudFront secret
        id: secrets
        run: |
          ARN="${{ steps.config.outputs.secrets_manager_arn }}"
          if [ -n "$ARN" ]; then
            echo "Fetching CloudFront secret header from AWS Secrets Manager..."
            SECRET_JSON=$(aws secretsmanager get-secret-value \
              --secret-id "$ARN" \
              --query SecretString \
              --output text)
            HEADER_NAME=$(echo "$SECRET_JSON" | jq -r '.header_name')
            HEADER_VALUE=$(echo "$SECRET_JSON" | jq -r '.header_value')
            echo "::add-mask::$HEADER_VALUE"
            echo "header_name=$HEADER_NAME" >> $GITHUB_OUTPUT
            echo "header_value=$HEADER_VALUE" >> $GITHUB_OUTPUT
            echo "Secret fetched successfully"
          else
            echo "CloudFront disabled or no secret ARN provided; skipping secret fetch."
            echo "header_name=" >> $GITHUB_OUTPUT
            echo "header_value=" >> $GITHUB_OUTPUT
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Ansible and dependencies
        run: |
          pip install --upgrade pip
          pip install ansible boto3 botocore
          ansible-galaxy collection install amazon.aws community.general

      - name: Install AWS Session Manager Plugin
        run: |
          curl "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"
          sudo dpkg -i session-manager-plugin.deb
          session-manager-plugin --version

      - name: Wait for instance to be ready
        if: ${{ inputs.instance_id != '' }}
        run: |
          echo "Waiting for SSM agent to be online..."
          INSTANCE_ID="${{ steps.config.outputs.instance_id }}"
          
          for i in {1..30}; do
            STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text 2>/dev/null || echo "NotFound")
            
            if [ "$STATUS" = "Online" ]; then
              echo "‚úÖ Instance is online and ready!"
              break
            fi
            
            echo "Attempt $i/30: Instance status is $STATUS, waiting 10s..."
            
            if [ $i -eq 30 ]; then
              echo "::error::Instance did not come online within timeout"
              exit 1
            fi
            
            sleep 10
          done

      - name: Verify AWS SSM connectivity
        run: |
          echo "Testing direct SSM connection..."
          aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=${{ steps.config.outputs.instance_id }}" \
            --query "InstanceInformationList[0]" || echo "SSM info retrieval failed"
          
          echo "Testing SSM command execution..."
          aws ssm send-command \
            --instance-ids "${{ steps.config.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["echo test"]' \
            --query "Command.CommandId" \
            --output text || echo "SSM send-command failed"

      - name: Create Ansible config and inventory
        run: |
          # Create ansible.cfg with SSM settings
          cat > ansible.cfg << 'EOFCFG'
          [defaults]
          host_key_checking = False
          inventory = inventory.ini
          timeout = 60
          
          [ssh_connection]
          
          [inventory]
          enable_plugins = aws_ec2, host_list, auto, yaml, ini
          EOFCFG
          
          # Create inventory with SSM connection params
          if [ -n "${{ inputs.ansible_inventory }}" ]; then
            echo "Using provided inventory content"
            printf "%s\n" "${{ inputs.ansible_inventory }}" > inventory.ini
          elif [ -n "${{ steps.config.outputs.instance_id }}" ]; then
            echo "Generating SSM inventory using instance_id"
            cat > inventory.ini <<EOFINV
          [ec2_servers]
          ec2-instance
          
          [ec2_servers:vars]
          ansible_host=${{ steps.config.outputs.instance_id }}
          ansible_connection=aws_ssm
          ansible_aws_ssm_region=${{ env.AWS_REGION }}
          EOFINV
          else
            echo "::error::Provide either 'instance_id' or 'ansible_inventory' input"
            exit 1
          fi
          
          echo "Ansible config created:"
          cat ansible.cfg
          echo ""
          echo "Inventory created:"
          cat inventory.ini

      - name: Test direct SSM command
        run: |
          echo "Testing direct SSM shell command..."
          aws ssm start-session --target ${{ steps.config.outputs.instance_id }} \
            --document-name AWS-StartNonInteractiveCommand \
            --parameters 'command=["echo SSM works"]' || echo "Direct SSM failed"

      - name: Skip Python bootstrap (already in AL2023)
        run: |
          echo "Amazon Linux 2023 includes Python3 by default; skipping bootstrap."

      - name: Deploy Nginx configuration via SSM
        run: |
          echo "Deploying Nginx configuration..."
          INSTANCE_ID="${{ steps.config.outputs.instance_id }}"
          
          # Create deployment script
          cat > deploy.sh << 'DEPLOY_EOF'
          #!/bin/bash
          set -e
          
          echo "Installing Nginx..."
          sudo dnf install -y nginx
          
          echo "Creating web root..."
          sudo mkdir -p /var/www/html
          sudo chown -R nginx:nginx /var/www/html
          
          echo "Downloading logo.png from repository..."
          sudo curl -L -o /var/www/html/logo.png \
            "https://raw.githubusercontent.com/${{ github.repository }}/${{ github.ref_name }}/logo.png" \
            || echo "Warning: Could not download logo.png"
          sudo chown nginx:nginx /var/www/html/logo.png || true
          
          echo "Creating index.html..."
          cat <<'HTML_EOF' | sudo tee /var/www/html/index.html
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Farming B.V. - Secure Logo Hosting</title>
              <style>
                  body { margin: 0; padding: 20px; display: flex; justify-content: center; 
                         align-items: center; min-height: 100vh; background-color: #f5f5f5; 
                         font-family: Arial, sans-serif; }
                  .container { text-align: center; max-width: 800px; }
                  h1 { color: #2c5f2d; margin-bottom: 10px; }
                  p { color: #666; margin-bottom: 30px; }
                  img { max-width: 100%; height: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.1); 
                        border-radius: 8px; }
              </style>
          </head>
          <body>
              <div class="container">
                  <h1>Farming B.V.</h1>
                  <p>Proudly serving groceries for over a century</p>
                  <img src="/logo.png" alt="Farming B.V. Logo" onerror="this.style.display='none'">
              </div>
          </body>
          </html>
          HTML_EOF
          
          echo "Configuring Nginx..."
          cat <<'NGINX_EOF' | sudo tee /etc/nginx/nginx.conf
          user nginx;
          worker_processes auto;
          error_log /var/log/nginx/error.log notice;
          pid /run/nginx.pid;
          
          events { worker_connections 1024; }
          
          http {
              include /etc/nginx/mime.types;
              default_type application/octet-stream;
              sendfile on;
              keepalive_timeout 65;
              server_tokens off;
              
              server {
                  listen 80;
                  server_name _;
                  root /var/www/html;
                  index index.html;
                  
                  location / { try_files \$uri \$uri/ =404; }
              }
          }
          NGINX_EOF
          
          echo "Testing Nginx configuration..."
          sudo nginx -t
          
          echo "Enabling and restarting Nginx..."
          sudo systemctl enable nginx
          sudo systemctl restart nginx
          
          echo "Configuring firewall..."
          sudo firewall-cmd --permanent --add-service=http || true
          sudo firewall-cmd --reload || true
          
          echo "Deployment complete!"
          DEPLOY_EOF
          
          chmod +x deploy.sh
          
          # Upload and execute script via SSM
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'curl -o /tmp/deploy.sh https://raw.githubusercontent.com/${{ github.repository }}/${{ github.ref_name }}/deploy.sh || cat > /tmp/deploy.sh',
              'bash /tmp/deploy.sh'
            ]" \
            --output text \
            --query "Command.CommandId" > command_id.txt
          
          COMMAND_ID=$(cat command_id.txt)
          echo "Command ID: $COMMAND_ID"
          
          # Wait for command to complete
          echo "Waiting for deployment to complete..."
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text)
            
            echo "Attempt $i/60: Status=$STATUS"
            
            if [ "$STATUS" = "Success" ]; then
              echo "‚úÖ Deployment completed successfully!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardOutputContent" \
                --output text
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "‚ùå Deployment failed!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi
            
            sleep 5
          done

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          CLOUDFRONT_URL="${{ steps.config.outputs.cloudfront_url }}"
          IMAGE_URL="${{ steps.config.outputs.image_url }}"
          
          if [ -n "$CLOUDFRONT_URL" ]; then
            echo "Testing CloudFront URL..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$CLOUDFRONT_URL" || echo 000)
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ CloudFront is responding correctly"
            else
              echo "‚ö†Ô∏è  CloudFront returned HTTP $HTTP_CODE (may need time to propagate)"
            fi
          else
            echo "CloudFront URL not provided; skipping CloudFront test."
          fi

          if [ -n "$IMAGE_URL" ]; then
            echo "Testing image URL..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$IMAGE_URL" || echo 000)
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Image is accessible"
            else
              echo "‚ö†Ô∏è  Image returned HTTP $HTTP_CODE (may need time to propagate)"
            fi
          else
            echo "Image URL not provided; skipping image test."
          fi

      - name: Test direct EC2 access (should be blocked)
        if: ${{ inputs.elastic_ip != '' }}
        continue-on-error: true
        run: |
          echo "Testing that direct EC2 access is blocked..."
          ELASTIC_IP="${{ steps.config.outputs.elastic_ip }}"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$ELASTIC_IP/logo.png" || echo "000")
          if [ "$HTTP_CODE" = "403" ]; then
            echo "‚úÖ Direct EC2 access is properly blocked (403 Forbidden)"
          elif [ "$HTTP_CODE" = "000" ]; then
            echo "‚úÖ Direct EC2 access is blocked (connection refused/timeout)"
          else
            echo "‚ö†Ô∏è  Direct EC2 returned HTTP $HTTP_CODE (expected 403)"
          fi

      - name: Display deployment summary
        if: success()
        run: |
          echo "============================================"
          echo "üéâ Deployment Completed Successfully!"
          echo "============================================"
          echo ""
          echo "üì∏ Image URL:"
          echo "   ${{ steps.config.outputs.image_url }}"
          echo ""
          echo "üåê CloudFront Distribution:"
          echo "   ${{ steps.config.outputs.cloudfront_url }}"
          echo ""
          echo "üîí Security Status:"
          echo "   ‚úÖ CloudFront HTTPS enforced"
          echo "   ‚úÖ Origin verification enabled"
          echo "   ‚úÖ Direct EC2 access blocked"
          echo "   ‚úÖ Security headers applied"
          echo ""
          echo "üß™ Test your deployment:"
          echo "   curl -I ${{ steps.config.outputs.image_url }}"
          echo ""
          echo "üì¶ Instance ID: ${{ steps.config.outputs.instance_id }}"
          echo "üîß Connect via SSM:"
          echo "   aws ssm start-session --target ${{ steps.config.outputs.instance_id }}"
          echo "============================================"

      - name: Upload deployment logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ansible-logs-${{ inputs.environment }}-${{ github.run_number }}
          path: |
            *.log
            deployment-config/
          retention-days: 7
          if-no-files-found: ignore
